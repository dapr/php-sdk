<?php

namespace Dapr\Dev;

use Dapr\Client\Interfaces\V1\DaprClientInterface;
use Dapr\Proto\Runtime\V1\DaprClient;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\PhpFile;

/**
 * Class GrpcUpgrader
 * @package Dapr\Dev
 */
class GrpcUpgrader
{
    protected ClassType $class;

    public function __construct(public string $file, public string $name)
    {
        $this->class = ClassType::withBodiesFrom($name);
    }

    public static function upgrade()
    {
        $base_dir = __DIR__.'/../src/grpc-generated';
        $files    = self::get_files($base_dir);
        foreach ($files as $file) {
            if (str_contains($file, 'GPBMetadata')) {
                continue;
            }
            $class    = str_replace($base_dir, '', $file);
            $class    = str_replace('.php', '', $class);
            $class    = str_replace('/', '\\', $class);
            $upgrader = new GrpcUpgrader($file, $class);
            $upgrader->do_upgrade();
        }
    }

    /**
     * @param string $dir
     *
     * @return array
     */
    protected static function get_files(string $dir): array
    {
        $files           = scandir($dir);
        $files_to_return = [];
        foreach ($files as $file) {
            if (in_array($file, ['.', '..'])) {
                continue;
            }
            $file = "$dir/$file";
            if (is_dir($file)) {
                $files_to_return = array_merge($files_to_return, self::get_files($file));
            }
            if (is_file($file)) {
                $files_to_return[] = $file;
            }
        }

        return $files_to_return;
    }

    public function do_upgrade(): void
    {
        echo "Enriching: {$this->name}\n";
        $this->enrich_methods();
        $this->maybe_extend();
        $this->write_file();
    }

    protected function enrich_methods(): void
    {
        foreach ($this->class->getMethods() as $method) {
            $return = $method->getReturnType() ?? $this->extract_tag($method->getComment(), '@return')['type'] ?? null;
            if ($return === null && $method->getName() !== '__construct' && ! str_contains(
                    $method->getBody(),
                    'return'
                )) {
                $return = 'void';
            }
            if ($return === null && str_contains($method->getBody(), 'return isset') && ! str_contains(
                    $method->getBody(),
                    "\n"
                )) {
                $return = 'bool';
            }
            $method->setReturnType($this->sanitize_type($return));

            foreach ($method->getParameters() as $parameter) {
                $type = $parameter->getType() ?? $this->extract_param_type(
                        $method->getComment(),
                        $parameter->getName()
                    );
                if($method->getName() === '__construct' && $parameter->getName() === 'opts') {
                    $type .= '|null';
                }
                $parameter->setType($this->sanitize_type($type));
                if ($type && $parameter->hasDefaultValue() && $parameter->getDefaultValue() === null) {
                    $parameter->setType($type.'|null');
                }
            }
        }
    }

    protected function extract_tag(string $doc, string $tag): array
    {
        preg_match('/'.$tag.' (?<type>\S+)\s*(?<name>\S+)*/m', $doc, $output_array);

        return $output_array;
    }

    protected function sanitize_type(string|null $types): string|null
    {
        $returns = [];
        if ($types === null) {
            return $types;
        }
        foreach (explode('|', $types) as $returnable) {
            $returns[] = match ($returnable) {
                default => str_ends_with($returnable, '[]') ? 'array' : $returnable,
                '$this' => $this->name
            };
        }

        return implode('|', $returns);
    }

    protected function extract_param_type(string $doc, string $param): null|string
    {
        preg_match('/@param (?<type>\S+)\s+\$'.$param.'/m', $doc, $output_array);

        return $output_array['type'] ?? null;
    }

    protected function maybe_extend(): void
    {
        if ($this->name === '\\'.DaprClient::class) {
            $this->class->addImplement(DaprClientInterface::class);
        }
    }

    protected function write_file(): void
    {
        $file = new PhpFile();
        $file->addComment('This file is automatically generated by `composer build-grpc`');
        $namespace = substr(str_replace('/', '\\', dirname(str_replace('\\', '/', $this->name))), 1);
        $namespace = $file->addNamespace($namespace);
        $namespace->add($this->class);
        file_put_contents($this->file, $file);
    }
}
